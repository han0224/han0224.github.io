---
layout: single
title: "[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] ë” ë§µê²Œ"
categories:
  - Programmers
tag: [Coding Test, JS, Heap]
toc: true
---


## ğŸ“– ë¬¸ì œ

[level2 ë” ë§µê²Œ](https://school.programmers.co.kr/learn/courses/30/lessons/42626)

## âœï¸ ë‚˜ì˜ í’€ì´

ë¬¸ì œëŠ” ìµœì†Œí™ë§Œ êµ¬í˜„í•˜ë©´ ê°„ë‹¨íˆ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œì˜€ë‹¤.

ì²˜ìŒì—ëŠ” ìµœì†Œí™ì´ ì•„ë‹Œ ì •ë ¬ë§Œì„ ì´ìš©í•´ í’€ë ¤ê³  í•´ë³´ë‹ˆ, ë‹¹ì—°í•˜ê²Œë„ ì‹œê°„ì´ˆê³¼ê°€ ë°œìƒí–ˆë‹¤.

### Heap

#### constructor

```javascript
constructor() {
    this.tree = [-1];
    this.size = 0;
}
```
- Heap ê°ì²´ê°€ ë§Œë“¤ì–´ ì§€ë©´, ë°°ì—´ê³¼ ë°°ì—´ ì•ˆì— ìˆëŠ” ìš”ì†Œ ê°¯ìˆ˜ì¸ size ë³€ìˆ˜ë¥¼ ì„ ì–¸ ë° ì´ˆê¸°í™” í•´ì¤€ë‹¤.
- 1ë²ˆ ì¸ë±ìŠ¤ë¶€í„° ì‚¬ìš©í•  ê²ƒì´ê¸°ì— 0ë²ˆì§¸ ì¸ë±ìŠ¤ì—ëŠ” -1ì„ ë„£ì–´ë‘ì—ˆë‹¤.
  - scovilleì˜ ì›ì†ŒëŠ” 0ì´ìƒ ì´ê¸°ì— -1ì„ ì €ì¥í–ˆë‹¤.

#### push
```javascript
push(num) {
    this.tree.push(num);
    let index = this.size + 1;
    let parentIndex = Math.floor(index / 2);

    this.size += 1;

    while (index > 1) {
        const currentValue = num;
        const parentValue = this.tree[parentIndex];
        if (num <= parentValue) {
            this.swap(parentIndex, index);
            index = parentIndex;
            parentIndex = Math.floor(index / 2);
        } else break;
    }
}
```
- heapì— ì›ì†Œë¥¼ ì¶”ê°€í•  ë•Œ ìš°ì„  ê°€ì¥ ë§¨ ë’¤ì— ìš”ì†Œë¥¼ ì¶”ê°€í•´ì¤€ë‹¤.
- ê·¸ë¦¬ê³  ì´ì œ ë¶€ëª¨ì™€ ë¹„êµí•˜ë©° heapì„ ì •ë¦¬í•´ì¤€ë‹¤.
- ë§Œì¼, ë¶€ëª¨ê°€ ìƒˆë¡œ ì¶”ê°€ëœ ì›ì†Œë³´ë‹¤ í¬ë©´ ë‘˜ì˜ ê°’ì„ ë³€ê²½í•´ì¤€ë‹¤.
- ê·¸ë‹¤ìŒ index ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì£¼ë©° ê³„ì† ë°˜ë³µí•´ì¤€ë‹¤.
- ë§Œì¼, index ê°’ì´ 1ë³´ë‹¤ ì‘ìœ¼ë©´ íŠ¸ë¦¬ì˜ ê°€ì¥ ìœ„ì— ì¡´ì¬í•˜ëŠ” ê²ƒì´ë¯€ë¡œ ë°˜ë³µë¬¸ì„ ì¢…ë£Œí•´ì¤€ë‹¤.
- ë˜í•œ, ë¶€ëª¨ì˜ ê°’ì´ ì¶”ê°€ëœ ì›ì†Œë³´ë‹¤ ì‘ìœ¼ë©´ ë”ì´ìƒ ê°’ì„ ë³€ê²½í•´ì¤„ í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ ë°˜ë³µë¬¸ì„ ì¢…ë£Œí•´ì¤€ë‹¤.

#### pop
```javascript
pop() {
    if (this.getSize() === 0) return null;
    if (this.getSize() === 1) {
        this.size -= 1;
        return this.tree.pop();
    }
    const last = this.tree.pop();
    const res = this.tree[1];

    this.tree[1] = last;
    this.size -= 1;

    let index = 1;
    let leftIndex = index * 2;
    let rightIndex = leftIndex + 1;

    while (
        (this.tree[leftIndex] && this.tree[leftIndex] < this.tree[index]) ||
        (this.tree[rightIndex] && this.tree[rightIndex] < this.tree[index])
    ) {
        let smallIndex = leftIndex;
        if (
            this.tree[rightIndex] &&
            this.tree[smallIndex] > this.tree[rightIndex]
        ) {
            smallIndex = rightIndex;
        }
        this.swap(index, smallIndex);
        index = smallIndex;

        leftIndex = index * 2;
        rightIndex = leftIndex + 1;
    }
    return res;
}
```
- ê°’ì„ ì œê±°í• ë•Œ ìš°ì„  `this.size` ê°€ 0ì´ë©´ ê°’ì´ ì—†ìœ¼ë¯€ë¡œ `null`ì„ ë°˜í™˜í•œë‹¤.
- `this.size`ê°€ 1ì´ë©´ ê°’ì´ í•˜ë‚˜ ì´ë¯€ë¡œ `this.size`ê°’ì„ 1ê°ì†Œì‹œí‚¤ê³  ë°°ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì„ ë°˜í™˜í•œë‹¤.
- ìœ„ ë‘ ì¡°ê±´ì— ì¶©ì¡±í•˜ì§€ ì•Šì€ ê²½ìš°
- ë°°ì—´ì˜ ë§ˆì§€ë§‰ ê°’ì„ `this.tree[1]`ì— ë„£ì–´ë‘ê³  ê¸°ì¡´ `this.tree[1]` ê°’ì€ ìµœì¢…ì ìœ¼ë¡œ ë°˜í™˜í•´ì£¼ê¸° ìœ„í•´ ì €ì¥í•´ë‘”ë‹¤.

- ì´ì œ ë°˜ë³µë¬¸ì„ ëŒë¦¬ë©° `this.tree[1]`ì— ìˆëŠ” ê°’ì„ ì˜¬ë°”ë¥¸ ìë¦¬ì— ì •ë ¬í•´ë‘ê¸° ìœ„í•´ ë°˜ë³µë¬¸ì„ ëŒë¦°ë‹¤.

```javascript
while (
        (this.tree[leftIndex] && this.tree[leftIndex] < this.tree[index]) ||
        (this.tree[rightIndex] && this.tree[rightIndex] < this.tree[index])
    )
```
- ë°˜ë³µë¬¸ì˜ ì¡°ê±´ì€ ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©°, ì™¼ìª½ ìì‹ì˜ ê°’ì´ ë¶€ëª¨ì˜ ê°’ë³´ë‹¤ ì‘ê±°ë‚˜,
- ì˜¤ë¥¸ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©°, ì˜¤ë¥¸ìª½ ìì‹ì˜ ê°’ì´ ë¶€ëª¨ì˜ ê°’ë³´ë‹¤ ì‘ì•„ì•¼í•œë‹¤.
- ìœ„ ë‘ ì¡°ê±´ ëª¨ë‘ ë§Œì¡±í•˜ì§€ ëª»í•˜ë©´ ë”ì´ìƒ ë³€ê²½ì‹œí‚¬ ê°’ì´ ì—†ìœ¼ë¯€ë¡œ ë°˜ë³µë¬¸ì„ ì¢…ë£Œí•œë‹¤.

```javascript
let smallIndex = leftIndex;
if (
    this.tree[rightIndex] &&
    this.tree[smallIndex] > this.tree[rightIndex]
) {
    smallIndex = rightIndex;
}
this.swap(index, smallIndex);
index = smallIndex;

leftIndex = index * 2;
rightIndex = leftIndex + 1;
```  
- ë°˜ë³µë¬¸ ë‚´ë¶€ì—ì„œëŠ” ìœ„ ì½”ë“œê°€ ë™ì‘í•œë‹¤.
- ìš°ì„  ì™¼ìª½ ìì‹ì˜ ê°’ì´ ì˜¤ë¥¸ìª½ ê°’ë³´ë‹¤ ì‘ë‹¤ê³  ê°€ì •ì„ í•œë‹¤.
  - smallIndex ëŠ” ê°’ì´ ì‘ì€ indexë¥¼ ì˜ë¯¸í•œë‹¤.
- ê·¸ ë‹¤ìŒ ì˜¤ë¥¸ìª½ ìì‹ì´ ì¡´ì¬í•˜ê³ , ì˜¤ë¥¸ìª½ ìì‹ì˜ ê°’ì´ ì™¼ìª½ ìì‹ì˜ ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ `smallIndex`ë¥¼ `rightIndex`ë¡œ ë³€ê²½í•œë‹¤.

```javascript
this.swap(index, smallIndex);
index = smallIndex;

leftIndex = index * 2;
rightIndex = leftIndex + 1;
```
- ê·¸ ë‹¤ìŒ ë‘ ê°’ì„ êµì²´í•˜ë©° indexê°’ì„ ì—…ë°ì´íŠ¸ ì‹œí‚¨ë‹¤.


## ğŸ‘©â€ğŸ’» ì½”ë“œ

```javascript
class Heap {
  constructor() {
    this.tree = [-1];
    this.size = 0;
  }

  swap(index1, index2) {
    [this.tree[index1], this.tree[index2]] = [
      this.tree[index2],
      this.tree[index1],
    ];
  }

  push(num) {
    this.tree.push(num);
    let index = this.size + 1;
    let parentIndex = Math.floor(index / 2);

    this.size += 1;

    while (index > 1) {
      const currentValue = num;
      const parentValue = this.tree[parentIndex];
      if (num <= parentValue) {
        this.swap(parentIndex, index);
        index = parentIndex;
        parentIndex = Math.floor(index / 2);
      } else break;
    }
  }

  pop() {
    if (this.getSize() === 0) return null;
    if (this.getSize() === 1) {
      this.size -= 1;
      return this.tree.pop();
    }
    const last = this.tree.pop();
    const res = this.tree[1];

    this.tree[1] = last;
    this.size -= 1;

    let index = 1;
    let leftIndex = index * 2;
    let rightIndex = leftIndex + 1;

    while (
      (this.tree[leftIndex] && this.tree[leftIndex] < this.tree[index]) ||
      (this.tree[rightIndex] && this.tree[rightIndex] < this.tree[index])
    ) {
      let smallIndex = leftIndex;
      if (
        this.tree[rightIndex] &&
        this.tree[smallIndex] > this.tree[rightIndex]
      ) {
        smallIndex = rightIndex;
      }
      this.swap(index, smallIndex);
      index = smallIndex;

      leftIndex = index * 2;
      rightIndex = leftIndex + 1;
    }
    return res;
  }

  getSize() {
    return this.size;
  }

  isCheck(K) {
    for (let i = 1; i < this.tree.length; i++) {
      if (this.tree[i] < K) return false;
    }
    return true;
  }
  print() {
    console.log(this.tree);
  }
}

function solution(scoville, K) {
  let answer = 0;
  const heap = new Heap();
  scoville.forEach((v) => {
    heap.push(v);
  });

  while (!heap.isCheck(K)) {
    const food1 = heap.pop();
    const food2 = heap.pop();
    if (!food1 || !food2) return -1;

    const newFood = food1 + food2 * 2;
    heap.push(newFood);
    answer += 1;
  }

  return answer;
}
```
